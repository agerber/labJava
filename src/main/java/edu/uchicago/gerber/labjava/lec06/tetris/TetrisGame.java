package edu.uchicago.gerber.labjava.lec06.tetris;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Random;
//This entire game and its inner classes were generated by chatGPT!
// Main Game Class
public class TetrisGame extends JPanel implements ActionListener {
    private Board board;
    private Tetrimino currentTetrimino;
    private Tetrimino nextTetrimino;
    private Timer timer;
    private int score;
    private int level;
    private boolean isGameOver;

    public TetrisGame() {
        board = new Board();
        score = 0;
        level = 1;
        isGameOver = false;
        currentTetrimino = Tetrimino.getRandomTetrimino();
        nextTetrimino = Tetrimino.getRandomTetrimino();

        timer = new Timer(400, this);
        timer.start();

        setFocusable(true);
        addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (!isGameOver) handleKeyPress(e);
            }
        });
    }

    private void handleKeyPress(KeyEvent e) {
        switch (e.getKeyCode()) {
            case KeyEvent.VK_LEFT -> currentTetrimino.moveLeft(board);
            case KeyEvent.VK_RIGHT -> currentTetrimino.moveRight(board);
            case KeyEvent.VK_DOWN -> currentTetrimino.fall(board);
            case KeyEvent.VK_UP -> currentTetrimino.rotate(board);
        }
        repaint();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (!isGameOver) gameUpdate();
        repaint();
    }

    private void gameUpdate() {
        if (!currentTetrimino.fall(board)) {
            board.addTetrimino(currentTetrimino);
            clearCompletedRows();
            updateGameStatus();
            currentTetrimino = nextTetrimino;
            nextTetrimino = Tetrimino.getRandomTetrimino();
            currentTetrimino.setPosition(board.getWidth() / 2, 0);
        }
    }

    private void clearCompletedRows() {
        int rowsCleared = board.clearFullRows();
        if (rowsCleared > 0) {
            score += calculateScore(rowsCleared);
            level = score / 1000 + 1;
            timer.setDelay(400 - (level * 20));
        }
    }

    private int calculateScore(int rowsCleared) {
        return switch (rowsCleared) {
            case 1 -> 100 * level;
            case 2 -> 300 * level;
            case 3 -> 500 * level;
            case 4 -> 800 * level; // Tetris
            default -> 0;
        };
    }

    private void updateGameStatus() {
        if (board.getHeightOccupied() > board.getHeight() * 0.9) {
            isGameOver = true;
            timer.stop();
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Image bufferImage = createImage(getWidth(), getHeight());
        Graphics bufferGraphics = bufferImage.getGraphics();

        board.draw(bufferGraphics);
        currentTetrimino.draw(bufferGraphics, board.getSquareSize());

        if (isGameOver) {
            bufferGraphics.drawString("Game Over!", getWidth() / 2 - 30, getHeight() / 2);
        }

        g.drawImage(bufferImage, 0, 0, this);
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Tetris Game");
        TetrisGame game = new TetrisGame();
        frame.add(game);
        frame.setSize(300, 600);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}

// Board Class
class Board {
    private final int WIDTH = 10;
    private final int HEIGHT = 20;
    private final int SQUARE_SIZE = 30;
    private boolean[][] grid = new boolean[HEIGHT][WIDTH];

    public void addTetrimino(Tetrimino tetrimino) {
        for (Position pos : tetrimino.getBlocks()) {
            grid[pos.getY()][pos.getX()] = true;
        }
    }

    public int clearFullRows() {
        int clearedRows = 0;
        for (int y = 0; y < HEIGHT; y++) {
            if (isRowFull(y)) {
                clearRow(y);
                clearedRows++;
            }
        }
        return clearedRows;
    }

    private boolean isRowFull(int y) {
        for (int x = 0; x < WIDTH; x++) {
            if (!grid[y][x]) return false;
        }
        return true;
    }

    private void clearRow(int row) {
        for (int y = row; y > 0; y--) {
            System.arraycopy(grid[y - 1], 0, grid[y], 0, WIDTH);
        }
        grid[0] = new boolean[WIDTH];
    }

    public int getWidth() {
        return WIDTH;
    }

    public int getHeight() {
        return HEIGHT;
    }

    public int getSquareSize() {
        return SQUARE_SIZE;
    }

    public void draw(Graphics g) {
        g.setColor(Color.GRAY);
        for (int y = 0; y < HEIGHT; y++) {
            for (int x = 0; x < WIDTH; x++) {
                if (grid[y][x]) {
                    g.fillRect(x * SQUARE_SIZE, y * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
                }
                g.drawRect(x * SQUARE_SIZE, y * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
            }
        }
    }

    public boolean checkCollision(Tetrimino tetrimino) {
        for (Position pos : tetrimino.getBlocks()) {
            int x = pos.getX();
            int y = pos.getY();
            if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT || grid[y][x]) {
                return true;
            }
        }
        return false;
    }

    public int getHeightOccupied() {
        int height = 0;
        for (int y = 0; y < HEIGHT; y++) {
            for (int x = 0; x < WIDTH; x++) {
                if (grid[y][x]) {
                    height = Math.max(height, HEIGHT - y);
                    break;
                }
            }
        }
        return height;
    }
}

// Tetrimino Class
class Tetrimino {
    private Position[] blocks;
    private TetriminoType type;

    public Tetrimino(TetriminoType type, Position[] blocks) {
        this.type = type;
        this.blocks = blocks;
    }

    public static Tetrimino getRandomTetrimino() {
        TetriminoType[] types = TetriminoType.values();
        TetriminoType randomType = types[new Random().nextInt(types.length)];
        return new Tetrimino(randomType, randomType.getShape());
    }

    public boolean fall(Board board) {
        for (Position block : blocks) {
            block.move(0, 1);
        }
        if (board.checkCollision(this)) {
            for (Position block : blocks) {
                block.move(0, -1);
            }
            return false;
        }
        return true;
    }

    public void moveLeft(Board board) { /* Move left logic */ }

    public void moveRight(Board board) { /* Move right logic */ }

    public void rotate(Board board) { /* Rotate logic */ }

    public Position[] getBlocks() { return blocks; }

    public void setPosition(int x, int y) { /* Set position logic */ }

    public void draw(Graphics g, int squareSize) {
        g.setColor(Color.RED);
        for (Position pos : blocks) {
            g.fillRect(pos.getX() * squareSize, pos.getY() * squareSize, squareSize, squareSize);
        }
    }
}

// Position Class
class Position {
    private int x, y;

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() { return x; }

    public int getY() { return y; }

    public void move(int dx, int dy) {
        x += dx;
        y += dy;
    }
}

// TetriminoType Enum
enum TetriminoType {
    S, L, O, Z, J, I, T;

    public Position[] getShape() {
        // Placeholder for shape coordinates
        return new Position[] { new Position(0, 0), new Position(1, 0), new Position(0, 1), new Position(1, 1) };
    }
}
